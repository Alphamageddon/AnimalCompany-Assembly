Type: Unity.Burst.BurstCompileAttribute

Method: Unity.Burst.FloatMode get_FloatMode()

Disassembly:
	0x036FB010 AND W0, W0, 0x1
	0x036FB014 LDR X30, [X31], #0x20

ISIL:
	001 Move W0, [X0+16]
	002 Return X0

Method: System.Void set_FloatMode(Unity.Burst.FloatMode value)

Disassembly:
	0x036FB018 RET
	0x036FB01C ADRP X0, 0x9FD000

ISIL:
	001 Move [X0+16], W1
	002 Return 

Method: Unity.Burst.FloatPrecision get_FloatPrecision()

Disassembly:
	0x036FB020 LDR X0, [X0 + 0x528]
	0x036FB024 BL 0x1C16D08

ISIL:
	001 Move W0, [X0+20]
	002 Return X0

Method: System.Void set_FloatPrecision(Unity.Burst.FloatPrecision value)

Disassembly:
	0x036FB028 BL 0x1C16F10
	0x036FB02C MOV X19, X0

ISIL:
	001 Move [X0+20], W1
	002 Return 

Method: System.Boolean get_CompileSynchronously()

Disassembly:
	0x036FB030 ADRP X0, 0xA29000
	0x036FB034 LDR X0, [X0 + 0xE68]
	0x036FB038 BL 0x1C16D08
	0x036FB03C MOV X1, X0
	0x036FB040 MOV X0, X19
	0x036FB044 MOV X2, X31
	0x036FB048 BL 0x330E100
	0x036FB04C ADRP X0, 0xA45000
	0x036FB050 LDR X0, [X0 + 0xD88]
	0x036FB054 BL 0x1C16D08
	0x036FB058 MOV X1, X0
	0x036FB05C MOV X0, X19
	0x036FB060 BL 0x1C16DEC
	0x036FB064 RET
	0x036FB068 RET
	0x036FB06C MOVZ W0, 0x1
	0x036FB070 RET
	0x036FB074 RET
	0x036FB078 RET
	0x036FB07C MOV W0, W31
	0x036FB080 RET
	0x036FB084 STP X29, X30, [X31 - 0x60]!
	0x036FB088 STP X28, X27, [X31 + 0x10]
	0x036FB08C STP X26, X25, [X31 + 0x20]
	0x036FB090 STP X24, X23, [X31 + 0x30]
	0x036FB094 STP X22, X21, [X31 + 0x40]
	0x036FB098 STP X20, X19, [X31 + 0x50]

ISIL:
	001 Move [X31-32], X30
	002 Move [X31+16], X20
	003 Move [X31+24], X19
	004 Move X20, 0xCE6000
	005 Move W8, [X20+3043]
	006 Move X19, X0
	007 Move TEMP, X8
	008 And TEMP, TEMP, 1
	009 Compare TEMP, 1
	010 JumpIfEqual {19}
	011 Move X0, 0x9FD000
	012 Move X0, [X0+3056]
	013 Call 0x1C17CF4
	014 Move X0, 0x9FD000
	015 Move X0, [X0+3064]
	016 Call 0x1C17CF4
	017 Move W8, 1
	018 Move [X20+3043], W8
	019 Add X19, X19, 24
	020 Move W8, [X19]
	021 Compare W8, 0
	022 JumpIfEqual {32}
	023 Move X8, 0x9FD000
	024 Move X8, [X8+3064]
	025 Move X0, X19
	026 Move X20, [X31+16]
	027 Move X19, [X31+24]
	028 Move X1, [X8]
	029 Move X30, [X31+32]
	030 Call Nullable`1<Boolean>.get_Value, X0
	031 Return X0
	032 Move X20, [X31+16]
	033 Move X19, [X31+24]
	034 Move W0, W31
	035 Move X30, [X31+32]
	036 Return X0

Method: System.Void set_CompileSynchronously(System.Boolean value)

Disassembly:
	0x036FB09C ADRP X19, 0xCE5000
	0x036FB0A0 LDRB W8, [X19 + 0xBF1]
	0x036FB0A4 TBNZ X8, 0x0, 0x36FB134
	0x036FB0A8 ADRP X0, 0xA45000
	0x036FB0AC LDR X0, [X0 + 0xD90]
	0x036FB0B0 BL 0x1C16CF4
	0x036FB0B4 ADRP X0, 0xA45000
	0x036FB0B8 LDR X0, [X0 + 0xCF0]
	0x036FB0BC BL 0x1C16CF4
	0x036FB0C0 ADRP X0, 0x9F8000
	0x036FB0C4 LDR X0, [X0 + 0xE00]
	0x036FB0C8 BL 0x1C16CF4
	0x036FB0CC ADRP X0, 0xA22000
	0x036FB0D0 LDR X0, [X0 + 0x48]
	0x036FB0D4 BL 0x1C16CF4
	0x036FB0D8 ADRP X0, 0xA22000
	0x036FB0DC LDR X0, [X0 + 0x50]
	0x036FB0E0 BL 0x1C16CF4
	0x036FB0E4 ADRP X0, 0x9F8000
	0x036FB0E8 LDR X0, [X0 + 0xE18]
	0x036FB0EC BL 0x1C16CF4
	0x036FB0F0 ADRP X0, 0x9F8000
	0x036FB0F4 LDR X0, [X0 + 0x9D0]
	0x036FB0F8 BL 0x1C16CF4
	0x036FB0FC ADRP X0, 0xA45000
	0x036FB100 LDR X0, [X0 + 0xD98]

ISIL:
	001 Move [X31-48], X30
	002 Move [X31+16], X22
	003 Move [X31+24], X21
	004 Move [X31+32], X20
	005 Move [X31+40], X19
	006 Move X22, 0xCE6000
	007 Move X21, 0x9FD000
	008 Move W8, [X22+3044]
	009 Move X21, [X21+4056]
	010 Move W20, W1
	011 Move X19, X0
	012 Move TEMP, X8
	013 And TEMP, TEMP, 1
	014 Compare TEMP, 1
	015 JumpIfEqual {21}
	016 Move X0, 0x9FD000
	017 Move X0, [X0+4056]
	018 Call 0x1C17CF4
	019 Move W8, 1
	020 Move [X22+3044], W8
	021 Move X2, [X21]
	022 And W1, W20, 1
	023 Add X0, X31, 12
	024 NotImplemented "Instruction STRH not yet implemented."
	025 Call Nullable`1<Boolean>..ctor, X0, X1
	026 NotImplemented "Instruction LDRH not yet implemented."
	027 Move X22, [X31+16]
	028 Move X21, [X31+24]
	029 NotImplemented "Instruction STRH not yet implemented."
	030 Move X20, [X31+32]
	031 Move X19, [X31+40]
	032 Move X30, [X31+48]
	033 Return 

Method: System.Boolean get_Debug()

Disassembly:
	0x036FB104 BL 0x1C16CF4
	0x036FB108 ADRP X0, 0xA45000
	0x036FB10C LDR X0, [X0 + 0xDA0]
	0x036FB110 BL 0x1C16CF4
	0x036FB114 ADRP X0, 0xA45000
	0x036FB118 LDR X0, [X0 + 0xD00]
	0x036FB11C BL 0x1C16CF4
	0x036FB120 ADRP X0, 0xA45000
	0x036FB124 LDR X0, [X0 + 0xDA8]
	0x036FB128 BL 0x1C16CF4
	0x036FB12C MOVZ W8, 0x1
	0x036FB130 STRB W8, [X19 + 0xBF1]
	0x036FB134 MOV X0, X31
	0x036FB138 BL 0x33C0128
	0x036FB13C CBZ X0, 0x36FB4F8
	0x036FB140 MOV X1, X31
	0x036FB144 BL 0x33C0134
	0x036FB148 CBZ X0, 0x36FB4F8
	0x036FB14C LDR X8, [X0 + 0x18]
	0x036FB150 MOV X19, X0
	0x036FB154 CMP W8, 0x1
	0x036FB158 B.LT 0x36FB4DC
	0x036FB15C ADRP X25, 0xA45000
	0x036FB160 ADRP X26, 0x9F8000
	0x036FB164 ADRP X27, 0xA22000
	0x036FB168 ADRP X23, 0xA45000
	0x036FB16C ADRP X28, 0xA45000

ISIL:
	001 Move [X31-32], X30
	002 Move [X31+16], X20
	003 Move [X31+24], X19
	004 Move X20, 0xCE6000
	005 Move W8, [X20+3045]
	006 Move X19, X0
	007 Move TEMP, X8
	008 And TEMP, TEMP, 1
	009 Compare TEMP, 1
	010 JumpIfEqual {19}
	011 Move X0, 0x9FD000
	012 Move X0, [X0+3056]
	013 Call 0x1C17CF4
	014 Move X0, 0x9FD000
	015 Move X0, [X0+3064]
	016 Call 0x1C17CF4
	017 Move W8, 1
	018 Move [X20+3045], W8
	019 Add X19, X19, 26
	020 Move W8, [X19]
	021 Compare W8, 0
	022 JumpIfEqual {32}
	023 Move X8, 0x9FD000
	024 Move X8, [X8+3064]
	025 Move X0, X19
	026 Move X20, [X31+16]
	027 Move X19, [X31+24]
	028 Move X1, [X8]
	029 Move X30, [X31+32]
	030 Call Nullable`1<Boolean>.get_Value, X0
	031 Return X0
	032 Move X20, [X31+16]
	033 Move X19, [X31+24]
	034 Move W0, W31
	035 Move X30, [X31+32]
	036 Return X0

Method: System.Void set_Debug(System.Boolean value)

Disassembly:
	0x036FB170 ADRP X29, 0x9F8000
	0x036FB174 LDR X25, [X25 + 0xD00]
	0x036FB178 LDR X26, [X26 + 0xE18]
	0x036FB17C LDR X27, [X27 + 0x50]
	0x036FB180 LDR X23, [X23 + 0xD98]
	0x036FB184 LDR X28, [X28 + 0xDA8]
	0x036FB188 LDR X29, [X29 + 0x9D0]
	0x036FB18C MOV X24, X31
	0x036FB190 AND X8, X8, 0x0
	0x036FB194 CMP X24, W8, UXTW
	0x036FB198 B.CS 0x36FB504
	0x036FB19C ADD X8, X19, X24, 0x3, LSL
	0x036FB1A0 LDR X0, [X8 + 0x20]
	0x036FB1A4 MOV X1, X31
	0x036FB1A8 BL 0x32D45AC
	0x036FB1AC LDR X8, [X25]
	0x036FB1B0 MOV X20, X0
	0x036FB1B4 LDR W9, [X8 + 0xE0]
	0x036FB1B8 CBNZ W9, 0x36FB1C8
	0x036FB1BC MOV X0, X8
	0x036FB1C0 BL 0x1C16DFC
	0x036FB1C4 LDR X8, [X25]
	0x036FB1C8 LDR X9, [X8 + 0xB8]
	0x036FB1CC LDR X21, [X9 + 0x10]
	0x036FB1D0 CBNZ X21, 0x36FB228
	0x036FB1D4 LDR W9, [X8 + 0xE0]

ISIL:
	001 Move [X31-48], X30
	002 Move [X31+16], X22
	003 Move [X31+24], X21
	004 Move [X31+32], X20
	005 Move [X31+40], X19
	006 Move X22, 0xCE6000
	007 Move X21, 0x9FD000
	008 Move W8, [X22+3046]
	009 Move X21, [X21+4056]
	010 Move W20, W1
	011 Move X19, X0
	012 Move TEMP, X8
	013 And TEMP, TEMP, 1
	014 Compare TEMP, 1
	015 JumpIfEqual {21}
	016 Move X0, 0x9FD000
	017 Move X0, [X0+4056]
	018 Call 0x1C17CF4
	019 Move W8, 1
	020 Move [X22+3046], W8
	021 Move X2, [X21]
	022 And W1, W20, 1
	023 Add X0, X31, 12
	024 NotImplemented "Instruction STRH not yet implemented."
	025 Call Nullable`1<Boolean>..ctor, X0, X1
	026 NotImplemented "Instruction LDRH not yet implemented."
	027 Move X22, [X31+16]
	028 Move X21, [X31+24]
	029 NotImplemented "Instruction STRH not yet implemented."
	030 Move X20, [X31+32]
	031 Move X19, [X31+40]
	032 Move X30, [X31+48]
	033 Return 

Method: System.Boolean get_DisableSafetyChecks()

Disassembly:
	0x036FB1D8 CBNZ W9, 0x36FB1E8
	0x036FB1DC MOV X0, X8
	0x036FB1E0 BL 0x1C16DFC
	0x036FB1E4 LDR X8, [X25]
	0x036FB1E8 LDR X8, [X8 + 0xB8]
	0x036FB1EC LDR X22, [X8]
	0x036FB1F0 ADRP X8, 0xA45000
	0x036FB1F4 LDR X8, [X8 + 0xCF0]
	0x036FB1F8 LDR X0, [X8]
	0x036FB1FC BL 0x1C16F10
	0x036FB200 ADRP X8, 0xA45000
	0x036FB204 LDR X8, [X8 + 0xDA0]
	0x036FB208 MOV X1, X22
	0x036FB20C MOV X3, X31
	0x036FB210 MOV X21, X0
	0x036FB214 LDR X2, [X8]
	0x036FB218 BL 0x2D2F428
	0x036FB21C LDR X8, [X25]
	0x036FB220 LDR X8, [X8 + 0xB8]
	0x036FB224 STR X21, [X8 + 0x10]
	0x036FB228 ADRP X8, 0xA45000
	0x036FB22C LDR X8, [X8 + 0xD90]
	0x036FB230 MOV X0, X20
	0x036FB234 MOV X1, X21
	0x036FB238 LDR X2, [X8]
	0x036FB23C BL 0x21DA490
	0x036FB240 CBZ X0, 0x36FB4F8

ISIL:
	001 Move [X31-32], X30
	002 Move [X31+16], X20
	003 Move [X31+24], X19
	004 Move X20, 0xCE6000
	005 Move W8, [X20+3047]
	006 Move X19, X0
	007 Move TEMP, X8
	008 And TEMP, TEMP, 1
	009 Compare TEMP, 1
	010 JumpIfEqual {19}
	011 Move X0, 0x9FD000
	012 Move X0, [X0+3056]
	013 Call 0x1C17CF4
	014 Move X0, 0x9FD000
	015 Move X0, [X0+3064]
	016 Call 0x1C17CF4
	017 Move W8, 1
	018 Move [X20+3047], W8
	019 Add X19, X19, 28
	020 Move W8, [X19]
	021 Compare W8, 0
	022 JumpIfEqual {32}
	023 Move X8, 0x9FD000
	024 Move X8, [X8+3064]
	025 Move X0, X19
	026 Move X20, [X31+16]
	027 Move X19, [X31+24]
	028 Move X1, [X8]
	029 Move X30, [X31+32]
	030 Call Nullable`1<Boolean>.get_Value, X0
	031 Return X0
	032 Move X20, [X31+16]
	033 Move X19, [X31+24]
	034 Move W0, W31
	035 Move X30, [X31+32]
	036 Return X0

Method: System.Void set_DisableSafetyChecks(System.Boolean value)

Disassembly:
	0x036FB244 LDR X8, [X0]
	0x036FB248 ADRP X10, 0xA22000
	0x036FB24C MOV X20, X0
	0x036FB250 LDRH W9, [X8 + 0x12E]
	0x036FB254 LDR X10, [X10 + 0x48]
	0x036FB258 LDR X1, [X10]
	0x036FB25C CBZ X9, 0x36FB280
	0x036FB260 LDR X10, [X8 + 0xB0]
	0x036FB264 ADD X10, X10, 0x8
	0x036FB268 LDUR X11, [X10 - 0x8]
	0x036FB26C CMP X11, X1
	0x036FB270 B.EQ 0x36FB290
	0x036FB274 SUBS X9, X9, 0x1
	0x036FB278 ADD X10, X10, 0x10
	0x036FB27C B.NE 0x36FB268
	0x036FB280 MOV X0, X20
	0x036FB284 MOV W2, W31
	0x036FB288 BL 0x1C5C788
	0x036FB28C B 0x36FB29C
	0x036FB290 LDRSW X9, [X10]
	0x036FB294 ADD X8, X8, X9, 0x4, LSL
	0x036FB298 ADD X0, X8, 0x138
	0x036FB29C LDP X8, X1, [X0]
	0x036FB2A0 MOV X0, X20
	0x036FB2A4 BLR X8
	0x036FB2A8 MOV X20, X0

ISIL:
	001 Move [X31-48], X30
	002 Move [X31+16], X22
	003 Move [X31+24], X21
	004 Move [X31+32], X20
	005 Move [X31+40], X19
	006 Move X22, 0xCE6000
	007 Move X21, 0x9FD000
	008 Move W8, [X22+3048]
	009 Move X21, [X21+4056]
	010 Move W20, W1
	011 Move X19, X0
	012 Move TEMP, X8
	013 And TEMP, TEMP, 1
	014 Compare TEMP, 1
	015 JumpIfEqual {21}
	016 Move X0, 0x9FD000
	017 Move X0, [X0+4056]
	018 Call 0x1C17CF4
	019 Move W8, 1
	020 Move [X22+3048], W8
	021 Move X2, [X21]
	022 And W1, W20, 1
	023 Add X0, X31, 12
	024 NotImplemented "Instruction STRH not yet implemented."
	025 Call Nullable`1<Boolean>..ctor, X0, X1
	026 NotImplemented "Instruction LDRH not yet implemented."
	027 Move X22, [X31+16]
	028 Move X21, [X31+24]
	029 NotImplemented "Instruction STRH not yet implemented."
	030 Move X20, [X31+32]
	031 Move X19, [X31+40]
	032 Move X30, [X31+48]
	033 Return 

Method: System.Boolean get_DisableDirectCall()

Disassembly:
	0x036FB2AC CBZ X0, 0x36FB494
	0x036FB2B0 LDR X8, [X20]
	0x036FB2B4 LDR X1, [X26]
	0x036FB2B8 LDRH W9, [X8 + 0x12E]
	0x036FB2BC CBZ X9, 0x36FB2E0
	0x036FB2C0 LDR X10, [X8 + 0xB0]
	0x036FB2C4 ADD X10, X10, 0x8
	0x036FB2C8 LDUR X11, [X10 - 0x8]
	0x036FB2CC CMP X11, X1
	0x036FB2D0 B.EQ 0x36FB2F0
	0x036FB2D4 SUBS X9, X9, 0x1
	0x036FB2D8 ADD X10, X10, 0x10
	0x036FB2DC B.NE 0x36FB2C8
	0x036FB2E0 MOV X0, X20
	0x036FB2E4 MOV W2, W31
	0x036FB2E8 BL 0x1C5C788
	0x036FB2EC B 0x36FB2FC
	0x036FB2F0 LDRSW X9, [X10]
	0x036FB2F4 ADD X8, X8, X9, 0x4, LSL
	0x036FB2F8 ADD X0, X8, 0x138
	0x036FB2FC LDP X8, X1, [X0]
	0x036FB300 MOV X0, X20
	0x036FB304 BLR X8
	0x036FB308 TBZ X0, 0x0, 0x36FB3EC
	0x036FB30C LDR X8, [X20]
	0x036FB310 LDR X1, [X27]
	0x036FB314 LDRH W9, [X8 + 0x12E]

ISIL:
	001 Move [X31-32], X30
	002 Move [X31+16], X20
	003 Move [X31+24], X19
	004 Move X20, 0xCE6000
	005 Move W8, [X20+3049]
	006 Move X19, X0
	007 Move TEMP, X8
	008 And TEMP, TEMP, 1
	009 Compare TEMP, 1
	010 JumpIfEqual {19}
	011 Move X0, 0x9FD000
	012 Move X0, [X0+3056]
	013 Call 0x1C17CF4
	014 Move X0, 0x9FD000
	015 Move X0, [X0+3064]
	016 Call 0x1C17CF4
	017 Move W8, 1
	018 Move [X20+3049], W8
	019 Add X19, X19, 30
	020 Move W8, [X19]
	021 Compare W8, 0
	022 JumpIfEqual {32}
	023 Move X8, 0x9FD000
	024 Move X8, [X8+3064]
	025 Move X0, X19
	026 Move X20, [X31+16]
	027 Move X19, [X31+24]
	028 Move X1, [X8]
	029 Move X30, [X31+32]
	030 Call Nullable`1<Boolean>.get_Value, X0
	031 Return X0
	032 Move X20, [X31+16]
	033 Move X19, [X31+24]
	034 Move W0, W31
	035 Move X30, [X31+32]
	036 Return X0

Method: System.Void set_DisableDirectCall(System.Boolean value)

Disassembly:
	0x036FB318 CBZ X9, 0x36FB33C
	0x036FB31C LDR X10, [X8 + 0xB0]
	0x036FB320 ADD X10, X10, 0x8
	0x036FB324 LDUR X11, [X10 - 0x8]
	0x036FB328 CMP X11, X1
	0x036FB32C B.EQ 0x36FB34C
	0x036FB330 SUBS X9, X9, 0x1
	0x036FB334 ADD X10, X10, 0x10
	0x036FB338 B.NE 0x36FB324
	0x036FB33C MOV X0, X20
	0x036FB340 MOV W2, W31
	0x036FB344 BL 0x1C5C788
	0x036FB348 B 0x36FB358
	0x036FB34C LDRSW X9, [X10]
	0x036FB350 ADD X8, X8, X9, 0x4, LSL
	0x036FB354 ADD X0, X8, 0x138
	0x036FB358 LDP X8, X1, [X0]
	0x036FB35C MOV X0, X20
	0x036FB360 BLR X8
	0x036FB364 CBZ X0, 0x36FB47C
	0x036FB368 LDR X9, [X0]
	0x036FB36C LDR X8, [X23]
	0x036FB370 LDRB W11, [X9 + 0x130]
	0x036FB374 LDRB W10, [X8 + 0x130]
	0x036FB378 CMP W11, W10
	0x036FB37C B.CC 0x36FB47C

ISIL:
	001 Move [X31-48], X30
	002 Move [X31+16], X22
	003 Move [X31+24], X21
	004 Move [X31+32], X20
	005 Move [X31+40], X19
	006 Move X22, 0xCE6000
	007 Move X21, 0x9FD000
	008 Move W8, [X22+3050]
	009 Move X21, [X21+4056]
	010 Move W20, W1
	011 Move X19, X0
	012 Move TEMP, X8
	013 And TEMP, TEMP, 1
	014 Compare TEMP, 1
	015 JumpIfEqual {21}
	016 Move X0, 0x9FD000
	017 Move X0, [X0+4056]
	018 Call 0x1C17CF4
	019 Move W8, 1
	020 Move [X22+3050], W8
	021 Move X2, [X21]
	022 And W1, W20, 1
	023 Add X0, X31, 12
	024 NotImplemented "Instruction STRH not yet implemented."
	025 Call Nullable`1<Boolean>..ctor, X0, X1
	026 NotImplemented "Instruction LDRH not yet implemented."
	027 Move X22, [X31+16]
	028 Move X21, [X31+24]
	029 NotImplemented "Instruction STRH not yet implemented."
	030 Move X20, [X31+32]
	031 Move X19, [X31+40]
	032 Move X30, [X31+48]
	033 Return 

Method: Unity.Burst.OptimizeFor get_OptimizeFor()

Disassembly:
	0x036FB380 LDR X11, [X9 + 0xC8]
	0x036FB384 ADD X11, X11, X10, 0x3, LSL

ISIL:
	001 Move W0, [X0+32]
	002 Return X0

Method: System.Void set_OptimizeFor(Unity.Burst.OptimizeFor value)

Disassembly:
	0x036FB388 LDUR X11, [X11 - 0x8]
	0x036FB38C CMP X11, X8

ISIL:
	001 Move [X0+32], W1
	002 Return 

Method: System.String[] get_Options()

Disassembly:
	0x036FB390 B.NE 0x36FB47C
	0x036FB394 LDR X9, [X9 + 0xC8]

ISIL:
	001 Move X0, [X0+40]
	002 Return X0

Method: System.Void set_Options(System.String[] value)

Disassembly:
	0x036FB398 ADD X9, X9, X10, 0x3, LSL
	0x036FB39C LDUR X9, [X9 - 0x8]

ISIL:
	001 Move [X0+40], X1
	002 Return 

Method: System.Void .ctor()

Disassembly:
	0x036FB3A0 CMP X9, X8
	0x036FB3A4 CSEL X8, X0, X31, EQ

ISIL:
	001 Move X1, X31
	002 Call Attribute..ctor, X0
	003 Return 

Method: System.Void .ctor(Unity.Burst.FloatPrecision floatPrecision, Unity.Burst.FloatMode floatMode)

Disassembly:
	0x036FB3A8 LDR X0, [X8 + 0x10]
	0x036FB3AC CBZ X0, 0x36FB48C
	0x036FB3B0 LDR X1, [X28]
	0x036FB3B4 MOVZ W2, 0x18
	0x036FB3B8 MOV X3, X31
	0x036FB3BC BL 0x3397600
	0x036FB3C0 MOV X21, X0
	0x036FB3C4 LDR X0, [X29]
	0x036FB3C8 MOV W1, W31
	0x036FB3CC BL 0x1C16D6C
	0x036FB3D0 CBZ X21, 0x36FB484

ISIL:
	001 Move [X31-32], X30
	002 Move [X31-24], X21
	003 Move [X31+16], X20
	004 Move [X31+24], X19
	005 Move W20, W1
	006 Move X1, X31
	007 Move W19, W2
	008 Move X21, X0
	009 Call Attribute..ctor, X0
	010 Move [X21+16], W19
	011 Move [X21+20], W20
	012 Move X20, [X31+16]
	013 Move X19, [X31+24]
	014 Move X30, [X31+32]
	015 Move X21, [X31+40]
	016 Return 

Method: System.Void .ctor(System.String[] options)

Disassembly:
	0x036FB3D4 MOV X2, X0
	0x036FB3D8 MOV X0, X21
	0x036FB3DC MOV X1, X31
	0x036FB3E0 MOV X3, X31
	0x036FB3E4 BL 0x32CE4E0
	0x036FB3E8 B 0x36FB2B0
	0x036FB3EC MOV X21, X31
	0x036FB3F0 MOVZ W22, 0x7
	0x036FB3F4 CBZ X20, 0x36FB458
	0x036FB3F8 LDR X8, [X20]

ISIL:
	001 Move [X31-32], X30
	002 Move [X31+16], X20
	003 Move [X31+24], X19
	004 Move X19, X1
	005 Move X1, X31
	006 Move X20, X0
	007 Call Attribute..ctor, X0
	008 Move [X20+40], X19
	009 Move X20, [X31+16]
	010 Move X19, [X31+24]
	011 Move X30, [X31+32]
	012 Return 

